<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&display=swap" rel="stylesheet">
  <title>About the Tests - Mosaic Project</title>
  <style>
    html { font-size: 16px; }
    body {
      font-family: 'Noto Sans JP', Arial, sans-serif;
      background-color: hsl(0, 0%, 10%);
      color: hsl(42, 100%, 80%);
      padding: 2rem;
      margin: 0;
    }
    .page { padding: 1.25rem; margin: 1.25rem auto; max-width: 46.875rem; background-color: hsl(0, 0%, 0%); box-shadow: 0 0 0.625rem hsl(42, 100%, 50%); }
    ul, li { font-size: 1rem; list-style-type: none; }
    li::before { content: "ðŸ“„ "; margin-right: 0.3125rem; }
    li { margin-bottom: 0.3125rem; }
    .description { margin-left: 0.625rem; color: hsl(42, 100%, 75%); }
    code { font-family: 'Courier New', Courier, monospace; background-color: hsl(0, 0%, 25%); color: hsl(42, 100%, 90%); padding: 0.125rem 0.25rem; border-radius: 0.1875rem; font-size: 90%; }
    h1 { text-align: center; color: hsl(42, 100%, 84%); text-transform: uppercase; margin-bottom: 1.25rem; }
    h2 { color: hsl(42, 100%, 84%); text-transform: uppercase; margin-top: 2.5rem; }
    p { color: hsl(42, 100%, 90%); margin-bottom: 1.25rem; text-align: justify; }
  </style>
</head>
<body>
  <div class="page">

    <h1>About the Tests</h1>

    <p>This document provides an operational guide for running and expanding
      tests of the Mosaic TestBench. I.e. it is not about running the Mosaic
      TestBench, rather it is about testing the Mosaic TestBench</p>

    <p>These tests are primarily ad hoc, as we avoid using the TestBench to test
    itself. Despite being ad hoc, the tests follow a core philosophy: the goal
    is to identify which functions fail, rather than diagnose why they fail. In
    the argot of the field, we are looking for function failures ad are not
    identifying falts. Hence, tests do not print messages but signal if they
    fail, or not.</p>

    <p>Accordingly, only pass/fail counts and the names of failing functions are
    recorded. For more detailed investigation, for locating the fault, the
    developer can run a failed test using a debugging tool such
    as <code>jdb</code>.</p>

    <h2>1. Running the Tests</h2>
    <p>To run all tests and gather results, follow these steps:</p>
    <ol>
      <li>Make sure no old files are hanging about by running <code>clean_build_directories</code>.</li>
      <li>Run <code>make</code> to compile the project and prepare all test class shell wrappers.</li>
      <li>Run <code>run_tests</code> to run the tests. Each test class will output
      its results, identifying tests that failed.</li>
    </ol>

    <h2>2. Ad Hoc Block Tests</h2>
    <p>The block tests are ad hoc and do not use TestBench directly. It would
      have been nice to have used the TestBench, but doing so would have
      introduce unnecessary complexity.</p>
    <ul>
      <li><strong>2.1 Each test group is a class.</strong></li>
      <ul>
        <li><span class="description">Each group of related tests is organized within its own class, keeping tests modular and focused.</span></li>
      </ul>
      <li><strong>2.2 Key Methods</strong></li>
      <ul>
        <li><span class="description"><code>main</code>: The entry point for command-line execution.</span></li>
        <li><span class="description"><code>run</code>: Aggregates test results, runs all methods in the class, and reports outcomes.</span></li>
      </ul>
      <li><strong>2.3 Helper and Test Methods</strong></li>
      <ul>
        <li><span class="description">Test methods take no arguments and return <code>true</code> if they pass; any other return value counts as a failure.</span></li>
      </ul>
    </ul>

    <h2>3. Integration Tests</h2>
    <p>After completion of the ad hoc block testing, integration of the blocks
      is tested with one or more tests that make use of the TestBench. The
      TestBench framework offers a structured testing approach. Classes using
      TestBench are referred to as Test Suites, each method within which is
      treated as an independent test.  </p>
    <ul>
      <li><strong>3.1 Test Suites</strong></li>
      <ul>

        <li><span class="description">Each Test Suite class extends
        the <code>TestBench</code> class.  Each method in a Test Suite runs as a
        separate test when the suite is executed.</span></li>
      </ul>
      <li><strong>3.2 Method Structure</strong></li>
      <ul>
        <li><span class="description">Each test method accepts a
        single <code>IO</code> argument (a utility class handling input/output
            streams) and returns a <code>Object</code>. Only a return value
            of Boolean <code>true</code> is counted as a pass.  Any other return
            value, any uncaught exceptions, or any data left on stdin, or stdout
            are taken to mean the test failed.</span></li>
      </ul>
    </ul>

    <h2>4. Adding a Test</h2>
    <p>To extend the testing suite, new tests can be added as follows:</p>
    <ul>
      <li><strong>4.1 Create or Extend a Test Class</strong></li>
      <ul>
        <li><span class="description">Add a new test class as required or append methods to an existing one.</span></li>
      </ul>
      <li><strong>4.2 Integrate the Test Class</strong></li>
      <ul>
        <li><span class="description">For classes with a <code>main</code> function, add the class name to <code>tool/shell_wrapper_list</code> to ensure it is included in the test environment.</span></li>
      </ul>
    </ul>

  </div>
</body>
</html>
